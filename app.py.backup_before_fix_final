import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import time
import os
import sys
import matplotlib.pyplot as plt
import random

# Essayer d'importer les modules pour les donn√©es r√©elles
try:
    # Importer le module pour l'onglet des donn√©es r√©elles
    from real_data_tab import display_real_data_tab
    
    # Importer les fonctions utilitaires pour les donn√©es r√©elles
    sys.path.append(os.path.dirname(os.path.abspath(__file__)))
    from utils.football_data import get_future_matches, get_team_form, get_head_to_head, get_team_stats
    from utils.prediction_analysis import get_prediction_data
    from utils.daily_combo import get_daily_combos, get_daily_combo_analysis
    from utils.live_monitoring import get_live_matches, get_match_timeline, get_match_momentum, get_live_alerts
    from utils.update_live_matches import update_live_matches
    from utils.live_sentinel_initializer import initialize_surveillance_data
except Exception as e:
    def get_live_matches():
        return []
    def get_live_alerts():
        return []

# Configuration de la page
st.set_page_config(
    page_title="ArcanShadow",
    page_icon="üîÆ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Fonction pour charger le CSS personnalis√©
def load_custom_css():
    """Charge le fichier CSS personnalis√© pour transformer l'interface ArcanShadow"""
    try:
        with open('.streamlit/style.css') as f:
            st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)
    except Exception as e:
        st.error(f"Erreur lors du chargement du CSS: {e}")

# Fonction d'aide pour les traductions
def t(key, **format_args):
    """Helper function to get text in the current language"""
    # Placeholder pour la fonction de traduction r√©elle
    translations = {
        "app_title": {"en": "ArcanShadow", "fr": "ArcanShadow"},
        "welcome_message": {
            "en": "Welcome to the future of sports prediction",
            "fr": "Bienvenue dans le futur de la pr√©diction sportive"
        },
        "todays_matches": {
            "en": "Today's Matches",
            "fr": "Matchs du jour"
        },
        "featured_matches": {
            "en": "Featured Matches",
            "fr": "Matchs √† la une"
        },
        "predictions": {
            "en": "Predictions",
            "fr": "Pr√©dictions"
        },
        "analysis": {
            "en": "Analysis",
            "fr": "Analyse"
        },
        "esoteric_panel": {
            "en": "Esoteric Insights",
            "fr": "Aper√ßus √âsot√©riques"
        }
    }
    
    # Langue par d√©faut (fran√ßais)
    lang = "fr"
    
    # Obtenir la traduction
    if key in translations and lang in translations[key]:
        text = translations[key][lang]
        # Appliquer les arguments de format s'il y en a
        if format_args:
            text = text.format(**format_args)
        return text
    return key

# Charger notre CSS personnalis√©
load_custom_css()

# Fonction simul√©e pour obtenir des donn√©es d'exemple
def get_sample_data():
    leagues = ["Ligue 1", "Premier League", "LaLiga", "Bundesliga", "Serie A"]
    teams = {
        "Ligue 1": ["PSG", "Marseille", "Lyon", "Monaco", "Lille"],
        "Premier League": ["Manchester City", "Liverpool", "Arsenal", "Chelsea", "Tottenham"],
        "LaLiga": ["Real Madrid", "Barcelona", "Atletico Madrid", "Sevilla", "Valencia"],
        "Bundesliga": ["Bayern Munich", "Dortmund", "RB Leipzig", "Leverkusen", "Frankfurt"],
        "Serie A": ["Inter", "Milan", "Juventus", "Napoli", "Roma"]
    }
    
    matches = []
    for league in leagues:
        for i in range(3):  # 3 matches par ligue
            home_idx = np.random.randint(0, len(teams[league]))
            away_idx = (home_idx + 1 + np.random.randint(0, len(teams[league])-1)) % len(teams[league])
            
            home_team = teams[league][home_idx]
            away_team = teams[league][away_idx]
            
            # Cotes g√©n√©r√©es al√©atoirement
            home_odds = round(1.5 + np.random.random() * 2, 2)
            draw_odds = round(3.0 + np.random.random() * 1.5, 2)
            away_odds = round(2.0 + np.random.random() * 3.5, 2)
            
            # Probabilit√©s d√©riv√©es des cotes
            total = 1/home_odds + 1/draw_odds + 1/away_odds
            home_prob = round((1/home_odds) / total, 2)
            draw_prob = round((1/draw_odds) / total, 2)
            away_prob = round((1/away_odds) / total, 2)
            
            # G√©n√©rer l'heure de coup d'envoi dans les 12 prochaines heures
            hours_ahead = np.random.randint(1, 12)
            match_time = (datetime.now() + timedelta(hours=hours_ahead)).strftime("%H:%M")
            
            # Pays pour les codes de drapeaux
            countries = {
                "Ligue 1": "fr", 
                "Premier League": "gb", 
                "LaLiga": "es", 
                "Bundesliga": "de", 
                "Serie A": "it"
            }
            
            match = {
                "league": league,
                "country": countries[league],
                "country_code": countries[league],
                "home_team": home_team,
                "away_team": away_team,
                "home": home_team,  # Alias pour compatibilit√©
                "away": away_team,  # Alias pour compatibilit√©
                "kickoff_time": match_time,
                "time": match_time,  # Ajout de la cl√© 'time' pour maintenir la compatibilit√©
                "home_odds": home_odds,
                "draw_odds": draw_odds,
                "away_odds": away_odds,
                "home_prob": home_prob,
                "draw_prob": draw_prob,
                "away_prob": away_prob
            }
            matches.append(match)
    
    # S'assurer qu'il y a des matchs √† afficher
    if not matches:
        return [], []
        
    # Marquer certains matchs comme importants
    num_featured = min(3, len(matches))
    featured_indices = np.random.choice(range(len(matches)), num_featured, replace=False)
    featured_matches = [matches[i] for i in featured_indices]
    
    # Retirer les matchs √† la une de la liste principale pour √©viter les doublons
    remaining_matches = [match for i, match in enumerate(matches) if i not in featured_indices]
    
    # Ajouter les cl√©s n√©cessaires s'il en manque
    for match in featured_matches + remaining_matches:
        if 'time' not in match and 'kickoff_time' in match:
            match['time'] = match['kickoff_time']
        if 'home' not in match and 'home_team' in match:
            match['home'] = match['home_team']
        if 'away' not in match and 'away_team' in match:
            match['away'] = match['away_team']
    
    return featured_matches, remaining_matches

# Importer le module de donn√©es de football r√©elles
import sys
import os

# Ajouter le r√©pertoire utils au chemin pour pouvoir importer les modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from utils.football_data import get_future_matches

# Charger les donn√©es de matchs r√©els depuis le d√©p√¥t football.json
try:
    # D√©finir les ligues principales √† charger
    main_leagues = ['en.1', 'es.1', 'it.1', 'de.1', 'fr.1', 'uefa.cl']
    
    # Obtenir les matchs r√©els √† venir dans les 10 prochains jours
    featured_matches, today_matches = get_future_matches(
        days_ahead=10,
        league_ids=main_leagues,
        season="2024-25"  # Utiliser la saison actuelle
    )
    
    # Si les donn√©es r√©elles sont insuffisantes, utiliser des donn√©es de secours
    if not featured_matches or len(featured_matches) < 3:
        featured_matches = [
            {
                "league": "Ligue 1",
                "country_code": "fr",
                "home_team": "PSG",
                "away_team": "Marseille",
                "home": "PSG",
                "away": "Marseille",
                "time": "20:45",
                "kickoff_time": "20:45",
                "date": "2025-05-24",
                "home_odds": 1.54,
                "draw_odds": 4.00,
                "away_odds": 6.67,
                "home_prob": 0.65,
                "draw_prob": 0.20,
                "away_prob": 0.15
            },
            {
                "league": "Premier League",
                "country_code": "gb",
                "home_team": "Liverpool",
                "away_team": "Arsenal",
                "home": "Liverpool",
                "away": "Arsenal",
                "time": "17:30",
                "kickoff_time": "17:30",
                "date": "2025-05-20",
                "home_odds": 1.82,
                "draw_odds": 4.00,
                "away_odds": 5.00,
                "home_prob": 0.55,
                "draw_prob": 0.25,
                "away_prob": 0.20
            },
            {
                "league": "LaLiga",
                "country_code": "es",
                "home_team": "Real Madrid",
                "away_team": "Barcelona",
                "home": "Real Madrid",
                "away": "Barcelona",
                "time": "21:00",
                "kickoff_time": "21:00",
                "date": "2025-05-25",
                "home_odds": 2.22,
                "draw_odds": 3.33,
                "away_odds": 4.00,
                "home_prob": 0.45,
                "draw_prob": 0.30,
                "away_prob": 0.25
            }
        ]
    
    # Si aucun match du jour n'est trouv√©, utiliser des matchs de secours
    if not today_matches:
        today_matches = [
            {
                "league": "Ligue 1",
                "country_code": "fr",
                "home_team": "Lyon",
                "away_team": "Monaco",
                "home": "Lyon",
                "away": "Monaco",
                "time": "19:00",
                "kickoff_time": "19:00",
                "date": "2025-05-20",
                "home_odds": 2.50,
                "draw_odds": 3.33,
                "away_odds": 3.33,
                "home_prob": 0.40,
                "draw_prob": 0.30,
                "away_prob": 0.30
            },
            {
                "league": "Bundesliga",
                "country_code": "de",
                "home_team": "Bayern Munich",
                "away_team": "Dortmund",
                "home": "Bayern Munich",
                "away": "Dortmund",
                "time": "18:30",
                "kickoff_time": "18:30",
                "date": "2025-05-23",
                "home_odds": 1.43,
                "draw_odds": 5.00,
                "away_odds": 10.00,
                "home_prob": 0.70,
                "draw_prob": 0.20,
                "away_prob": 0.10
            },
            {
                "league": "Serie A",
                "country_code": "it",
                "home_team": "Juventus",
                "away_team": "Napoli",
                "home": "Juventus",
                "away": "Napoli",
                "time": "20:45",
                "kickoff_time": "20:45",
                "date": "2025-05-21",
                "home_odds": 2.50,
                "draw_odds": 3.33,
                "away_odds": 3.33,
                "home_prob": 0.40,
                "draw_prob": 0.30,
                "away_prob": 0.30
            }
        ]
    
    # Assurer que les matchs ont tous les champs requis
    for match in featured_matches + today_matches:
        # Garantir que les alias sont pr√©sents
        if 'home_team' in match and 'home' not in match:
            match['home'] = match['home_team']
        if 'away_team' in match and 'away' not in match:
            match['away'] = match['away_team']
        # Garantir que les temps sont pr√©sents
        if 'kickoff_time' in match and 'time' not in match:
            match['time'] = match['kickoff_time']
        elif 'time' in match and 'kickoff_time' not in match:
            match['kickoff_time'] = match['time']
    
except Exception as e:
    print(f"Erreur lors du chargement des donn√©es de football: {e}")
    # Cr√©er des donn√©es de secours en cas d'erreur
    featured_matches = [
        {
            "league": "Champions League",
            "country_code": "eu",
            "home_team": "Manchester City",
            "away_team": "Real Madrid",
            "home": "Manchester City",
            "away": "Real Madrid",
            "time": "21:00",
            "kickoff_time": "21:00",
            "date": "2025-05-25",
            "home_odds": 2.00,
            "draw_odds": 3.50,
            "away_odds": 4.00,
            "home_prob": 0.50,
            "draw_prob": 0.28,
            "away_prob": 0.22
        }
    ]
    today_matches = [
        {
            "league": "Premier League",
            "country_code": "gb",
            "home_team": "Liverpool",
            "away_team": "Manchester United",
            "home": "Liverpool",
            "away": "Manchester United",
            "time": "17:30",
            "kickoff_time": "17:30",
            "date": "2025-05-18",
            "home_odds": 1.67,
            "draw_odds": 4.00,
            "away_odds": 5.00,
            "home_prob": 0.60,
            "draw_prob": 0.25,
            "away_prob": 0.15
        }
    ]

# Interface principale
st.title(f"üîÆ {t('app_title')}")
st.markdown(f"### {t('welcome_message')}")

# Simuler un nombre de notifications non lues
if 'notification_count' not in st.session_state:
    st.session_state.notification_count = 3

# Cr√©er les onglets sp√©cifiques au syst√®me ArcanShadow
tabs = st.tabs([
    "üîç Surveillance en direct", 
    "üîÆ Pr√©dictions",
    "üîî Performance Notifications", 
    "üéØ Daily Combo", 
    "üí° Smart Market Recommendations", 
    "üß† Syst√®me d'Apprentissage",
    f"üì¨ Notifications ({st.session_state.notification_count})",
    "üåü Aper√ßus & Matchs Sp√©ciaux",
    "üåç Donn√©es R√©elles" # Nouvel onglet avec les donn√©es r√©elles
])

with tabs[0]:  # Live Monitoring (Surveillance en direct)
    # Importer et utiliser notre nouveau module avec des donn√©es r√©elles
    from live_surveillance_tab import display_surveillance_tab
    
    # Afficher l'onglet avec des donn√©es r√©elles de football
    display_surveillance_tab()
                
                with col1:
                    # Score et temps
                    st.markdown(f"""
                    <div style="text-align: center; background: rgba(8, 15, 40, 0.8); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <div style="font-size: 18px; color: rgba(255, 255, 255, 0.8);">{selected_match['league']}</div>
                        <div style="display: flex; justify-content: center; align-items: center; margin: 15px 0;">
                            <div style="flex: 1; text-align: right; padding-right: 15px;">
                                <div style="font-size: 24px; font-weight: bold; color: white;">{selected_match['home_team']}</div>
                            </div>
                            <div style="padding: 0 15px;">
                                <div style="font-size: 32px; font-weight: bold; color: white;">{selected_match['home_score']} - {selected_match['away_score']}</div>
                                <div style="font-size: 14px; color: #01ff80;">{selected_match['period']} ‚Ä¢ {selected_match['minute']}'</div>
                            </div>
                            <div style="flex: 1; text-align: left; padding-left: 15px;">
                                <div style="font-size: 24px; font-weight: bold; color: white;">{selected_match['away_team']}</div>
                            </div>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                    
                    # Statistiques du match
                    st.markdown("### Statistiques")
                    stats = selected_match['stats']
                    
                    # Cr√©er une visualisation des statistiques
                    stats_cols = st.columns(3)
                    
                    with stats_cols[0]:
                        st.metric("Possession", f"{stats['possession']}%", delta=None)
                        st.metric("Tirs", f"{stats['shots']}", delta=None)
                        
                    with stats_cols[1]:
                        st.metric("Tirs cadr√©s", f"{stats['shots_on_target']}", delta=None)
                        st.metric("Corners", f"{stats['corners']}", delta=None)
                        
                    with stats_cols[2]:
                        st.metric("Cartons jaunes", f"{stats['yellow_cards']}", delta=None)
                        st.metric("Cartons rouges", f"{stats['red_cards']}", delta=None)
                    
                    # Derniers √©v√©nements
                    st.markdown("### Derniers √©v√©nements")
                    events = selected_match['recent_events']
                    
                    for event in events:
                        event_type = event['type']
                        minute = event['minute']
                        team = event['team']
                        description = event.get('description', '')
                        
                        # Couleur selon le type d'√©v√©nement
                        if event_type == 'but':
                            color = "#01ff80"
                            icon = "‚öΩ"
                        elif event_type == 'carton':
                            color = "#ffbe41" if event.get('card_type', '') == 'jaune' else "#ff3364"
                            icon = "üü®" if event.get('card_type', '') == 'jaune' else "üü•"
                        elif event_type == 'occasion':
                            color = "#7000ff"
                            icon = "üéØ"
                        elif event_type == 'remplacement':
                            color = "#516395"
                            icon = "üîÑ"
                        else:
                            color = "white"
                            icon = "üö©"
                        
                        st.markdown(f"""
                        <div style="display: flex; align-items: center; margin-bottom: 10px; background: rgba(8, 15, 40, 0.5); padding: 10px; border-radius: 5px;">
                            <div style="min-width: 40px; text-align: center; font-weight: bold; color: {color};">{minute}'</div>
                            <div style="min-width: 30px; text-align: center; font-size: 18px;">{icon}</div>
                            <div style="flex-grow: 1; padding-left: 10px; color: white;">{description}</div>
                        </div>
                        """, unsafe_allow_html=True)
                    
                with col2:
                    # Cotes en direct
                    st.markdown("### Cotes live")
                    live_odds = selected_match['live_odds']
                    
                    st.markdown(f"""
                    <div style="padding: 15px; background: rgba(17, 23, 64, 0.7); border-radius: 10px; margin-bottom: 15px;">
                        <div style="margin-bottom: 10px; display: flex; justify-content: space-between;">
                            <div style="color: rgba(255, 255, 255, 0.7);">1</div>
                            <div style="color: rgba(255, 255, 255, 0.7);">X</div>
                            <div style="color: rgba(255, 255, 255, 0.7);">2</div>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <div style="font-size: 20px; font-weight: bold; color: white;">{live_odds['home_win']}</div>
                            <div style="font-size: 20px; font-weight: bold; color: white;">{live_odds['draw']}</div>
                            <div style="font-size: 20px; font-weight: bold; color: white;">{live_odds['away_win']}</div>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                    
                    # Momentum
                    st.markdown("### Momentum")
                    momentum = selected_match['momentum']
                    
                    # Cr√©er une jauge de momentum
                    fig = go.Figure(go.Indicator(
                        mode = "gauge+number",
                        value = momentum,
                        domain = {'x': [0, 1], 'y': [0, 1]},
                        title = {'text': "Indice de momentum", 'font': {'color': 'white', 'size': 14}},
                        gauge = {
                            'axis': {'range': [0, 100], 'tickcolor': "white"},
                            'bar': {'color': "#7000ff"},
                            'bgcolor': "rgba(8, 15, 40, 0.7)",
                            'borderwidth': 0,
                            'steps': [
                                {'range': [0, 40], 'color': 'rgba(255, 51, 100, 0.3)'},
                                {'range': [40, 60], 'color': 'rgba(255, 190, 65, 0.3)'},
                                {'range': [60, 100], 'color': 'rgba(1, 255, 128, 0.3)'}
                            ],
                        },
                        number = {'font': {'color': 'white'}}
                    ))
                    
                    fig.update_layout(
                        paper_bgcolor = 'rgba(0,0,0,0)',
                        plot_bgcolor = 'rgba(0,0,0,0)',
                        font = {'color': 'white'},
                        height = 250,
                        margin = dict(l=20, r=20, t=30, b=20)
                    )
                    
                    st.plotly_chart(fig, use_container_width=True)
                    
                    # Alertes
                    st.markdown("### Alertes sp√©ciales")
                    
                    # G√©n√©rer des alertes adapt√©es au match
                    alert_types = ["Momentum", "Cote", "Tendance"]
                    alert_selected = random.choice(alert_types)
                    
                    if alert_selected == "Momentum":
                        if momentum > 60:
                            team_type = "l'√©quipe √† domicile"
                        elif momentum < 40:
                            team_type = "l'√©quipe √† l'ext√©rieur"
                        else:
                            team_type = "aucune √©quipe"
                        alert_content = f"Forte dynamique en faveur de {team_type}"
                        alert_color = "#01ff80" if momentum > 60 or momentum < 40 else "#ffbe41"
                    elif alert_selected == "Cote":
                        if live_odds['home_win'] < 2.0:
                            odds_team = "l'√©quipe √† domicile"
                        elif live_odds['away_win'] < 2.5:
                            odds_team = "l'√©quipe √† l'ext√©rieur"
                        else:
                            odds_team = "le match nul"
                        alert_content = f"Les cotes pour {odds_team} ont significativement √©volu√©"
                        alert_color = "#01ff80"
                    else:
                        team_name = selected_match['home_team'] if stats['shots'] > 8 else selected_match['away_team']
                        alert_content = f"Le match pr√©sente une tendance inhabituelle dans les statistiques de {team_name}"
                        alert_color = "#7000ff"
                        
                    st.markdown(f"""
                    <div style="padding: 15px; background: rgba(8, 15, 40, 0.8); border-radius: 10px; border-left: 4px solid {alert_color};">
                        <div style="font-weight: bold; color: {alert_color}; margin-bottom: 5px;">{alert_selected.upper()}</div>
                        <div style="color: white;">{alert_content}</div>
                    </div>
                    """, unsafe_allow_html=True)
                
                # R√©cup√©rer les alertes en direct
                st.markdown("### üö® Alertes en direct")
                live_alerts = get_live_alerts()
                
                if live_alerts:
                    alert_cols = st.columns(len(live_alerts))
                    
                    for i, alert in enumerate(live_alerts):
                        alert_type = alert['type']
                        timestamp = alert['timestamp']
                        match_name = alert['match']
                        title = alert['title']
                        content = alert['content']
                        importance = alert['importance']
                        
                        # D√©terminer la couleur selon l'importance
                        if importance == 'high':
                            color = "#ff3364"
                        elif importance == 'medium':
                            color = "#ffbe41"
                        else:
                            color = "#516395"
                            
                        with alert_cols[i]:
                            st.markdown(f"""
                            <div style="border-left: 3px solid {color}; padding: 10px; background: rgba(8, 15, 40, 0.6); border-radius: 5px; height: 100%;">
                                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.7);">{timestamp}</div>
                                <div style="font-weight: bold; color: white; margin: 5px 0;">{title}</div>
                                <div style="font-size: 13px; color: rgba(255, 255, 255, 0.9); margin-bottom: 8px;">{match_name}</div>
                                <div style="font-size: 14px; color: white;">{content}</div>
                            </div>
                            """, unsafe_allow_html=True)
                else:
                    st.info("Aucune alerte en direct disponible actuellement.")
        else:
            st.info("Aucun match en direct disponible actuellement. Veuillez v√©rifier plus tard.")
            
            # Afficher un exemple d'interface
            st.markdown("""
            ### Interface de suivi en direct (exemple)
            
            Lorsque des matchs sont en direct, vous pourrez suivre:
            - Score en temps r√©el
            - Statistiques du match
            - Derniers √©v√©nements importants
            - √âvolution du momentum
            - Alertes sp√©ciales et opportunit√©s
            """)
            
    except Exception as e:
        st.error(f"Une erreur s'est produite lors du chargement des matchs en direct: {str(e)}")
        # Afficher l'interface simul√©e de base
    
    # Section d'activation d'ArcanSentinel sur les matchs en direct
    st.markdown("### üîç Activation d'ArcanSentinel pour les Matchs en Direct")
    
    st.markdown("""
    <div style="padding: 15px; border-radius: 10px; background: linear-gradient(135deg, rgba(8, 15, 40, 0.7), rgba(17, 23, 64, 0.6)); 
                border: 1px solid rgba(81, 99, 149, 0.3); margin-bottom: 15px;">
        <div style="font-size: 16px; font-weight: bold; color: #05d9e8; margin-bottom: 10px;">
            Mode ArcanSentinel - Analyse en Direct
        </div>
        <p style="color: rgba(255, 255, 255, 0.8); font-size: 14px; line-height: 1.6;">
            ArcanSentinel est une version all√©g√©e et ultra-r√©active d'ArcanShadow sp√©cialement con√ßue pour l'analyse en direct.
            L'activation automatique permet une surveillance en temps r√©el des matchs en cours avec r√©action imm√©diate aux √©v√©nements
            et ajustement dynamique des pr√©dictions pendant le d√©roulement du match.
            <br><br>
            Les r√©sultats de l'analyse en direct sont automatiquement int√©gr√©s au syst√®me d'apprentissage et apparaissent 
            dans l'onglet Notifications en temps r√©el.
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Structure pour les matchs en direct
    if 'live_matches' not in st.session_state:
        st.session_state.live_matches = [
            {"id": 1, "home": "PSG", "away": "Lyon", "league": "Ligue 1", "time": "20:45", "status": "En direct", "minute": "37'", "score": "1-0"},
            {"id": 2, "home": "Liverpool", "away": "Arsenal", "league": "Premier League", "time": "17:30", "status": "En direct", "minute": "68'", "score": "2-1"},
            {"id": 3, "home": "Bayern Munich", "away": "Dortmund", "league": "Bundesliga", "time": "18:30", "status": "En direct", "minute": "52'", "score": "0-0"}
        ]
    
    # Structure pour g√©rer les matchs surveill√©s en direct
    if 'sentinel_monitored_live_matches' not in st.session_state:
        st.session_state.sentinel_monitored_live_matches = []
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        # Tableau des matchs en direct disponibles
        st.markdown("#### üî¥ Matchs actuellement en direct")
        
        for match in st.session_state.live_matches:
            is_monitored = any(m['id'] == match['id'] for m in st.session_state.sentinel_monitored_live_matches)
            status_color = "#01ff80" if is_monitored else "rgba(255, 255, 255, 0.8)"
            status_text = "üü¢ Surveill√© en direct" if is_monitored else "‚ö™ Disponible"
            
            st.markdown(f"""
            <div style="display: flex; justify-content: space-between; align-items: center; 
                      padding: 12px; border-radius: 5px; margin-bottom: 15px; 
                      background: rgba(255, 51, 100, 0.1); border: 1px solid rgba(255, 51, 100, 0.2);">
                <div>
                    <div style="font-weight: bold; font-size: 16px; color: white;">
                        {match['home']} {match['score']} {match['away']}
                    </div>
                    <div style="font-size: 13px; color: #ff3364; font-weight: bold; margin-top: 4px;">
                        {match['minute']} ‚Ä¢ EN DIRECT
                    </div>
                    <div style="font-size: 12px; color: rgba(255, 255, 255, 0.6); margin-top: 2px;">
                        {match['league']}
                    </div>
                </div>
                <div style="font-size: 13px; color: {status_color};">
                    {status_text}
                </div>
            </div>
            """, unsafe_allow_html=True)
            
            # Pour chaque match, ajouter des boutons d'action
            col_a, col_b = st.columns([3, 2])
            with col_a:
                if not is_monitored:
                    if st.button(f"Activer surveillance en direct", key=f"activate_live_{match['id']}"):
                        # Configuration de surveillance
                        surveillance_config = {
                            "id": match['id'],
                            "home": match['home'],
                            "away": match['away'],
                            "league": match['league'],
                            "minute": match['minute'],
                            "score": match['score'],
                            "monitoring_level": "Maximum",  # Plus haut niveau pour les matchs en direct
                            "modules": ["ShadowMomentum", "LineTrap", "KarmicFlow", "MirrorPhase", "BetPulse"],
                            "activated_at": "2025-05-17 " + datetime.now().strftime("%H:%M:%S"),
                            "alert_threshold": 5  # Seuil plus bas pour √™tre plus r√©actif aux matchs en direct
                        }
                        st.session_state.sentinel_monitored_live_matches.append(surveillance_config)
                        
                        # Ajouter une notification d'activation
                        if 'notifications' in st.session_state:
                            new_notif = {
                                "id": len(st.session_state.notifications) + 1,
                                "type": "sentinel",
                                "title": f"üî¥ ArcanSentinel activ√© en DIRECT: {match['home']} vs {match['away']}",
                                "message": f"Surveillance instantan√©e lanc√©e sur le match en direct {match['home']} vs {match['away']} ({match['minute']}). Les analyses seront envoy√©es en temps r√©el.",
                                "timestamp": datetime.now().strftime("2025-05-17 %H:%M:%S"),
                                "read": False,
                                "priority": "urgent"
                            }
                            st.session_state.notifications.append(new_notif)
                            st.session_state.notification_count += 1
                            st.rerun()
                else:
                    if st.button(f"D√©sactiver la surveillance", key=f"deactivate_live_{match['id']}"):
                        # Retirer la surveillance
                        st.session_state.sentinel_monitored_live_matches = [
                            m for m in st.session_state.sentinel_monitored_live_matches if m['id'] != match['id']
                        ]
                        
                        # Ajouter une notification de d√©sactivation
                        if 'notifications' in st.session_state:
                            new_notif = {
                                "id": len(st.session_state.notifications) + 1,
                                "type": "sentinel",
                                "title": f"‚ö™ ArcanSentinel d√©sactiv√©: {match['home']} vs {match['away']}",
                                "message": f"La surveillance en direct du match {match['home']} vs {match['away']} a √©t√© d√©sactiv√©e. Les derni√®res analyses ont √©t√© sauvegard√©es.",
                                "timestamp": datetime.now().strftime("2025-05-17 %H:%M:%S"),
                                "read": False,
                                "priority": "medium"
                            }
                            st.session_state.notifications.append(new_notif)
                            st.session_state.notification_count += 1
                            st.rerun()
    
    with col2:
        # Configuration d'ArcanSentinel
        st.markdown("#### ‚öôÔ∏è Configuration Sentinel")
        
        monitoring_style = st.radio(
            "Style de surveillance:",
            ["Standard", "Aggressif", "Ultra-r√©actif"],
            index=2,
            help="D√©termine la sensibilit√© des alertes et la fr√©quence d'analyse"
        )
        
        notification_lvl = st.select_slider(
            "Niveau de notification:",
            options=["Minimal", "Normal", "D√©taill√©", "Complet"],
            value="D√©taill√©",
            help="Contr√¥le la quantit√© d'informations dans les alertes"
        )
        
        st.markdown("##### Modules Sentinel actifs:")
        col_m1, col_m2 = st.columns(2)
        
        with col_m1:
            st.checkbox("ShadowMomentum", value=True)
            st.checkbox("LineTrap", value=True)
            st.checkbox("KarmicFlow", value=True)
        
        with col_m2:
            st.checkbox("MirrorPhase", value=True)
            st.checkbox("BetPulse", value=True)
            st.checkbox("QuantumVar", value=False)
            
    # Statistiques de surveillance
    st.markdown("### üìä Statistiques de Surveillance")
    
    col_s1, col_s2, col_s3, col_s4 = st.columns(4)
    
    with col_s1:
        st.metric(label="Matchs surveill√©s", value=f"{len(st.session_state.sentinel_monitored_live_matches)}/3", delta="+1")
    
    with col_s2:
        st.metric(label="Alertes g√©n√©r√©es", value="14", delta="+3")
    
    with col_s3:
        st.metric(label="Pr√©cision des alertes", value="92%", delta="+4%")
    
    with col_s4:
        st.metric(label="Temps de r√©ponse", value="1.3s", delta="-0.2s")
        
    # Visualisation des activit√©s r√©centes d'ArcanSentinel
    st.markdown("### üì° Activit√© r√©cente d'ArcanSentinel")
    
    # Cr√©er des exemples d'activit√©s r√©centes
    recent_activities = [
        {"time": "17:32:45", "match": "Liverpool vs Arsenal", "event": "Momentum shift d√©tect√© pour Liverpool (+23%)", "impact": "high"},
        {"time": "17:28:12", "match": "PSG vs Lyon", "event": "S√©quence de jeu intense d√©tect√©e dans la zone critique", "impact": "medium"},
        {"time": "17:25:30", "match": "Bayern Munich vs Dortmund", "event": "Changement tactique identifi√©: Dortmund 4-3-3 ‚Üí 3-5-2", "impact": "high"},
        {"time": "17:18:47", "match": "Liverpool vs Arsenal", "event": "Blessure potentielle d√©tect√©e: joueur #7", "impact": "medium"},
        {"time": "17:15:22", "match": "PSG vs Lyon", "event": "Pression d√©fensive accrue de Lyon (+32% d'intensit√©)", "impact": "low"}
    ]
    
    for activity in recent_activities:
        impact_color = "#ff3364" if activity["impact"] == "high" else "#ffbe41" if activity["impact"] == "medium" else "#01ff80"
        
        st.markdown(f"""
        <div style="display: flex; padding: 10px; border-radius: 5px; margin-bottom: 8px; 
                  background: rgba(8, 15, 40, 0.5); border-left: 3px solid {impact_color};">
            <div style="min-width: 80px; font-size: 13px; color: rgba(255, 255, 255, 0.7);">
                {activity["time"]}
            </div>
            <div style="flex-grow: 1;">
                <div style="font-size: 14px; color: white;">
                    {activity["event"]}
                </div>
                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.6); margin-top: 3px;">
                    {activity["match"]}
                </div>
            </div>
        </div>
        """, unsafe_allow_html=True)
    with st.sidebar:
        st.markdown("## üîØ Aper√ßus √âsot√©riques")
        
        # Tarot du jour
        st.markdown("### üÉè Tarot du jour")
        tarot_cards = ["Le Magicien", "La Grande Pr√™tresse", "L'Imp√©ratrice", "L'Empereur", "Le Pape"]
        daily_tarot = np.random.choice(tarot_cards)
        st.markdown(f"**Carte dominante:** {daily_tarot}")
        
        # Runes nordiques
        st.markdown("### ·ö† Runes Actives")
        runes = ["Fehu (Prosp√©rit√©)", "Uruz (Force)", "Thurisaz (Protection)", "Ansuz (Communication)"]
        active_runes = np.random.choice(runes, 2, replace=False)
        st.markdown(f"**Influence primaire:** {active_runes[0]}")
        st.markdown(f"**Influence secondaire:** {active_runes[1]}")
        
        # Influences astrales
        st.markdown("### ‚ôÉ Influences Astrales")
        planets = ["Jupiter ‚¨ÜÔ∏è", "Mars ‚¨áÔ∏è", "V√©nus ‚ÜîÔ∏è", "Mercure ‚¨ÜÔ∏è", "Saturne ‚¨áÔ∏è"]
        active_planets = np.random.choice(planets, 3, replace=False)
        for planet in active_planets:
            st.markdown(f"‚Ä¢ {planet}")
    
    # Cette section a √©t√© d√©plac√©e vers l'onglet "Aper√ßus & Matchs Sp√©ciaux"

with tabs[1]:  # Pr√©dictions
    # Importer le module d'analyse de pr√©dictions
    from utils.prediction_analysis import get_prediction_data
    from utils.football_data import get_future_matches
    
    # R√©cup√©rer toutes les donn√©es de matchs pour les analyses
    try:
        # Obtenir les donn√©es compl√®tes des ligues principales
        main_leagues = ['en.1', 'es.1', 'it.1', 'de.1', 'fr.1', 'uefa.cl']
        all_featured, all_matches = get_future_matches(
            days_ahead=60,  # Utiliser une plage plus large pour les analyses
            league_ids=main_leagues,
            season="2024-25"
        )
        
        # Combiner toutes les donn√©es de matchs pour l'analyse
        all_match_data = all_featured + all_matches
    except Exception as e:
        st.error(f"Erreur lors du chargement des donn√©es pour les pr√©dictions: {str(e)}")
        all_match_data = []
    
    st.markdown("## üîÆ Pr√©dictions d'ArcanShadow")
    st.markdown("Analyse d√©taill√©e des pr√©dictions pour les matchs s√©lectionn√©s, avec explication des modules contributeurs.")
    
    # S√©lection du match √† analyser
    st.markdown("### ‚öΩ S√©lectionner un match")
    
    # Pr√©parer la liste des matchs √† venir pour la s√©lection
    match_options = []
    for match in all_match_data:
        if isinstance(match, dict):
            home = match.get('home_team', match.get('home', '?'))
            away = match.get('away_team', match.get('away', '?'))
            league = match.get('league', '?')
            time = match.get('time', '??:??')
            date = match.get('formatted_date', match.get('date', ''))
            
            # Cl√© unique pour retrouver le match s√©lectionn√©
            match['selection_key'] = f"{home} vs {away} ({league}) - {date} {time}"
            match_options.append(match['selection_key'])
    
    # Si aucun match n'est disponible, afficher des options par d√©faut
    if not match_options:
        match_options = [
            "PSG vs Lyon (Ligue 1) - 20:45",
            "Real Madrid vs Barcelona (LaLiga) - 21:00",
            "Liverpool vs Arsenal (Premier League) - 17:30",
            "Bayern Munich vs Dortmund (Bundesliga) - 18:30",
            "Inter vs Milan (Serie A) - 20:45"
        ]
    
    # Tri par date pour avoir les matchs les plus proches en premier
    match_options.sort()
    
    # Widget de s√©lection du match
    selected_match_key = st.selectbox("Match √† analyser:", match_options)
    
    # Trouver le match s√©lectionn√©
    selected_match = None
    for match in all_match_data:
        if isinstance(match, dict) and match.get('selection_key') == selected_match_key:
            selected_match = match
            break
    
    # Si match non trouv√©, cr√©er un match factice
    if not selected_match:
        # Extraire les informations du match s√©lectionn√©
        try:
            match_parts = selected_match_key.split(" (")
            teams = match_parts[0].split(" vs ")
            home_team = teams[0]
            away_team = teams[1]
            league_parts = match_parts[1].split(") - ")
            league = league_parts[0]
            time_parts = league_parts[1].split(" ") if len(league_parts) > 1 else ["??:??"]
            
            selected_match = {
                "home_team": home_team,
                "away_team": away_team,
                "league": league,
                "time": time_parts[-1] if len(time_parts) > 0 else "??:??",
                "home": home_team,
                "away": away_team
            }
        except Exception:
            # En cas d'erreur, cr√©er un match par d√©faut
            selected_match = {
                "home_team": "Liverpool",
                "away_team": "Arsenal",
                "league": "Premier League",
                "time": "17:30",
                "home": "Liverpool",
                "away": "Arsenal"
            }
    
    # Analyser le match s√©lectionn√©
    prediction_data = get_prediction_data(selected_match, all_match_data)
    
    # Afficher le r√©sum√© de la pr√©diction
    st.markdown(f"### üìä Pr√©diction pour {prediction_data['match_info']['home_team']} vs {prediction_data['match_info']['away_team']}")
    
    # En-t√™te de la pr√©diction avec conteneur principal
    with st.container():
        col_header1, col_header2 = st.columns([3, 1])
        with col_header1:
            st.subheader("Pr√©diction principale")
        with col_header2:
            confidence = prediction_data['main_prediction']['confidence']
            confidence_color = "#01ff80" if confidence >= 85 else "#ffbe41" if confidence >= 75 else "#ff3364"
            st.markdown(
                f"""
                <div style="background: rgba(1, 255, 128, 0.1); padding: 5px 10px; border-radius: 5px; 
                        border: 1px solid rgba(1, 255, 128, 0.3); color: {confidence_color}; font-weight: bold; text-align: center;">
                    Confiance: {confidence}%
                </div>
                """,
                unsafe_allow_html=True
            )
    
    # R√©sultat le plus probable
    st.markdown(
        f"""
        <div style="background: rgba(112, 0, 255, 0.1); padding: 15px; border-radius: 8px; 
                border: 1px solid rgba(112, 0, 255, 0.2); margin-bottom: 15px;">
            <table width="100%" style="border-collapse: collapse;">
                <tr>
                    <td>
                        <div style="font-size: 18px; color: rgba(255, 255, 255, 0.9);">R√©sultat le plus probable</div>
                        <div style="font-size: 28px; font-weight: bold; color: #7000ff;">{prediction_data['main_prediction']['outcome']}</div>
                    </td>
                    <td align="right">
                        <div style="font-size: 24px; font-weight: bold; color: white;">{prediction_data['main_prediction']['odds']}</div>
                    </td>
                </tr>
            </table>
        </div>
        """,
        unsafe_allow_html=True
    )
    
    # Titre des autres sc√©narios
    st.subheader("Autres sc√©narios")
    
    # Les sc√©narios en 2 colonnes (premier arrangement)
    col1, col2 = st.columns(2)
    
    # Premier groupe de deux sc√©narios
    for i, scenario in enumerate(prediction_data['other_scenarios'][:2]):
        col = col1 if i == 0 else col2
        with col:
            scenario_color = "#01ff80" if scenario['probability'] >= 80 else "#ffbe41" if scenario['probability'] >= 50 else "#ff3364"
            st.markdown(
                f"""
                <div style="padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 5px; margin-bottom: 10px;">
                    <table width="100%" style="border-collapse: collapse;">
                        <tr>
                            <td><div style="color: white;">{scenario['name']}</div></td>
                            <td align="right"><div style="color: {scenario_color};">{scenario['odds']} <span style="opacity: 0.7; font-size: 0.9em;">({scenario['probability']}%)</span></div></td>
                        </tr>
                    </table>
                </div>
                """,
                unsafe_allow_html=True
            )
    
    # Les sc√©narios en 2 colonnes (deuxi√®me arrangement)
    col3, col4 = st.columns(2)
    
    # Deuxi√®me groupe de deux sc√©narios
    for i, scenario in enumerate(prediction_data['other_scenarios'][2:]):
        col = col3 if i == 0 else col4
        with col:
            scenario_color = "#01ff80" if scenario['probability'] >= 80 else "#ffbe41" if scenario['probability'] >= 50 else "#ff3364"
            st.markdown(
                f"""
                <div style="padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 5px;">
                    <table width="100%" style="border-collapse: collapse;">
                        <tr>
                            <td><div style="color: white;">{scenario['name']}</div></td>
                            <td align="right"><div style="color: {scenario_color};">{scenario['odds']} <span style="opacity: 0.7; font-size: 0.9em;">({scenario['probability']}%)</span></div></td>
                        </tr>
                    </table>
                </div>
                """,
                unsafe_allow_html=True
            )
    
    # Modules contributeurs et leur impact
    st.markdown("### üß† Modules contributeurs")
    
    # V√©rifier si les donn√©es de module contributeur existent
    if 'contributing_modules' in prediction_data:
        # Cr√©er un dataframe pour les modules contributeurs
        df_modules_contrib = pd.DataFrame(prediction_data['contributing_modules'])
        
        # Calculer l'impact de chaque module (confiance √ó poids)
        df_modules_contrib["impact"] = df_modules_contrib["confidence"] * df_modules_contrib["weight"]
        
        # Trier par impact
        df_modules_contrib = df_modules_contrib.sort_values(by="impact", ascending=False)
    else:
        # Cr√©er des donn√©es simul√©es si les donn√©es r√©elles ne sont pas disponibles
        df_modules_contrib = pd.DataFrame({
            "module": ["ArcanX", "TarotEcho", "KarmicFlow+", "NumeriCode", "MetaSystems"],
            "confidence": [0.85, 0.92, 0.78, 0.81, 0.76],
            "weight": [0.35, 0.20, 0.15, 0.15, 0.15],
            "impact": [0.298, 0.184, 0.117, 0.122, 0.114]
        })
    
    # Cr√©er une visualisation pour montrer la contribution de chaque module
    fig = px.bar(
        df_modules_contrib,
        x="impact",
        y="module",
        orientation='h',
        labels={"impact": "Impact sur la pr√©diction", "module": "Module"},
        title="Contribution des modules √† la pr√©diction finale",
        color="confidence",
        text=df_modules_contrib["impact"].apply(lambda x: f"{x:.2f}"),
        color_continuous_scale=["red", "gold", "green"],
        range_color=[0.6, 1.0],
        height=400
    )
    
    fig.update_layout(
        template="plotly_dark", 
        yaxis=dict(autorange="reversed"),
        dragmode=False,
        xaxis=dict(fixedrange=True),  # D√©sactive le zoom sur l'axe X
        yaxis_fixedrange=True         # D√©sactive le zoom sur l'axe Y
    )
    
    # Rendre le graphique compl√®tement statique
    st.plotly_chart(
        fig, 
        use_container_width=True, 
        config={
            'staticPlot': True,               # Force un plot statique
            'displayModeBar': False,          # Masque la barre d'outils
            'showTips': False,                # D√©sactive les astuces
            'doubleClick': False,             # D√©sactive le double-clic
            'showAxisDragHandles': False,     # D√©sactive les poign√©es d'axe
            'showAxisRangeEntryBoxes': False, # D√©sactive les bo√Ætes de plage d'axe
            'displaylogo': False              # D√©sactive le logo Plotly
        }
    )
    
    # Afficher les insights cl√©s de chaque module
    st.markdown("### üîë Insights cl√©s par module")
    
    for i, module in enumerate(df_modules_contrib.to_dict('records')):
        confidence = module["confidence"]
        confidence_color = "#01ff80" if confidence >= 0.85 else "#ffbe41" if confidence >= 0.75 else "#ff3364"
        
        st.markdown(f"""
        <div style="padding: 12px; border-radius: 8px; background: rgba(8, 15, 40, 0.6); 
                    border-left: 4px solid {confidence_color}; margin-bottom: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="font-weight: bold; font-size: 16px;">{module.get("module", "Module inconnu")}</div>
                <div style="color: {confidence_color}; font-family: 'JetBrains Mono', monospace;">
                    Confiance: {int(confidence * 100)}%
                </div>
            </div>
            <div style="margin-top: 5px; color: rgba(255, 255, 255, 0.8);">
                {module.get("key_insights", "Pas d'insights disponibles pour ce module.")}
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # Narratif de la pr√©diction
    st.markdown("### üìú Narratif de la pr√©diction")
    
    # Utiliser un style d√©fini s√©par√©ment
    narrative_style = """
    <div style="padding: 15px; border-radius: 10px; background: rgba(112, 0, 255, 0.05); 
                border: 1px solid rgba(112, 0, 255, 0.2); margin-bottom: 20px;">
        <p style="color: rgba(255, 255, 255, 0.85); font-size: 16px; line-height: 1.6;">
    """
    
    narrative_end = """
        </p>
    </div>
    """
    
    # Pr√©parer le narratif avec des paragraphes HTML
    narrative_text = prediction_data['narrative']
    narrative_paragraphs = narrative_text.split('\n\n')
    
    # Commencer le narratif avec le style
    html_narrative = narrative_style
    
    # Ajouter chaque paragraphe
    for i, paragraph in enumerate(narrative_paragraphs):
        if paragraph.strip():
            if i > 0:
                html_narrative += "<br><br>"
            html_narrative += paragraph.strip()
    
    # Terminer le narratif
    html_narrative += narrative_end
    
    # Afficher le narratif format√©
    st.markdown(html_narrative, unsafe_allow_html=True)
    
with tabs[2]:  # Performance Notifications
    st.markdown("## üîî Notifications de Performance")
    st.markdown("Suivi et analyse des performances pr√©dictives du syst√®me ArcanShadow avec comparaison aux r√©sultats r√©els.")
    
    # En-t√™te avec statistiques globales
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric(label="Pr√©cision Globale", value="78%", delta="+2.3%")
    with col2:
        st.metric(label="ROI Hebdomadaire", value="12.7%", delta="+0.8%")
    with col3:
        st.metric(label="Modules Actifs", value="14/16", delta="+1")
    with col4:
        st.metric(label="√âchantillon", value="342 matchs", delta="+47")
    
    # Tableau des performances r√©centes
    st.markdown("### üìà Bilan de Synth√®se (7 derniers jours)")
    
    # Cr√©er des donn√©es de performance simul√©es
    performance_data = {
        "Date": [(datetime.now() - timedelta(days=i)).strftime("%d/%m/%Y") for i in range(7)],
        "Matchs": [np.random.randint(12, 25) for _ in range(7)],
        "Pr√©dictions Correctes": [np.random.randint(8, 20) for _ in range(7)],
        "Pr√©cision": [f"{np.random.randint(65, 90)}%" for _ in range(7)],
        "Module Star": np.random.choice(["ArcanX", "ShadowOdds", "NumeriCode", "KarmicFlow+", "AstroImpact"], 7)
    }
    
    # Calculer le taux de pr√©cision
    for i in range(7):
        matches = performance_data["Matchs"][i]
        correct = performance_data["Pr√©dictions Correctes"][i]
        performance_data["Pr√©cision"][i] = f"{round((correct / matches) * 100)}%"
    
    df_performance = pd.DataFrame(performance_data)
    st.dataframe(df_performance, use_container_width=True)
    
    # Graphique de performance des modules
    st.markdown("### üß© Performance des Modules Pr√©dictifs")
    
    modules = ["ArcanX", "ShadowOdds", "NumeriCode", "KarmicFlow+", "AstroImpact", 
               "EchoPath", "TarotEcho", "ShadowOdds+", "MetaSystems"]
    accuracy = [np.random.uniform(0.65, 0.92) for _ in modules]
    sample_size = [np.random.randint(50, 300) for _ in modules]
    
    # Trier par pr√©cision
    sorted_indices = sorted(range(len(accuracy)), key=lambda i: accuracy[i], reverse=True)
    sorted_modules = [modules[i] for i in sorted_indices]
    sorted_accuracy = [accuracy[i] for i in sorted_indices]
    sorted_sample = [sample_size[i] for i in sorted_indices]
    
    # Cr√©er un dataframe
    df_modules = pd.DataFrame({
        "Module": sorted_modules,
        "Pr√©cision": sorted_accuracy,
        "√âchantillon": sorted_sample
    })
    
    # Cr√©er un graphique √† barres horizontal statique
    fig = px.bar(
        df_modules, y="Module", x="Pr√©cision", 
        orientation='h',
        title="Pr√©cision par Module (30 derniers jours)",
        color="Pr√©cision",
        color_continuous_scale=["red", "gold", "green"],
        range_color=[0.5, 1.0],
        text=df_modules["Pr√©cision"].apply(lambda x: f"{x:.1%}"),
        height=500
    )
    
    fig.update_layout(
        xaxis_title="Pr√©cision (%)",
        yaxis_title="Module Pr√©dictif",
        template="plotly_dark",
        dragmode=False,
        hovermode=False
    )
    
    # Afficher le graphique de mani√®re statique (sans interaction)
    st.plotly_chart(fig, use_container_width=True, config={'displayModeBar': False, 'staticPlot': True})
    
    # Alertes et recommandations de calibration
    st.markdown("### ‚ö†Ô∏è Alertes et Recommandations")
    
    alert1, alert2 = st.columns(2)
    
    with alert1:
        st.markdown("""
        <div style="padding: 15px; border-radius: 10px; background-color: rgba(255, 51, 100, 0.1); border: 1px solid rgba(255, 51, 100, 0.3);">
            <h4 style="color: #ff3364;">‚ö†Ô∏è Module en sous-performance</h4>
            <p><b>EchoPath</b> montre une baisse de pr√©cision de 8.7% sur les 14 derniers jours. Recalibration recommand√©e.</p>
        </div>
        """, unsafe_allow_html=True)
        
    with alert2:
        st.markdown("""
        <div style="padding: 15px; border-radius: 10px; background-color: rgba(1, 255, 128, 0.1); border: 1px solid rgba(1, 255, 128, 0.3);">
            <h4 style="color: #01ff80;">‚úÖ Module surperformant</h4>
            <p><b>ShadowOdds+</b> affiche une pr√©cision exceptionnelle de 91.3% dans la Ligue 1. Augmentation de pond√©ration recommand√©e.</p>
        </div>
        """, unsafe_allow_html=True)


with tabs[3]:  # Daily Combo
    st.markdown("## üéØ Combin√© du Jour")
    st.markdown("S√©lection automatique optimis√©e des meilleures opportunit√©s de paris, bas√©e sur les modules les plus performants.")
    
    # Param√®tres du combin√©
    col1, col2, col3 = st.columns([2, 1, 1])
    
    with col1:
        st.markdown("### ‚öôÔ∏è Configuration")
        confidence_level = st.slider("Niveau de confiance minimum", 60, 95, 75, 5)
        
    with col2:
        st.metric(label="Nombre de S√©lections", value="3")
        st.metric(label="Cote Combin√©e", value="7.36")
    
    with col3:
        st.metric(label="Confiance Globale", value="83%", delta="+8%")
        st.metric(label="Module Dominant", value="ArcanX")
    
    # S√©lection des modules performants
    st.markdown("### üß© Modules Utilis√©s (s√©lection automatique)")
    
    modules_used = ["ArcanX", "ShadowOdds+", "KarmicFlow+", "MetaSystems"]
    module_weights = [0.35, 0.25, 0.22, 0.18]
    
    # Cr√©er un graphique camembert statique
    fig_modules = px.pie(
        values=module_weights, 
        names=modules_used,
        title="Pond√©ration des modules pour le combin√©",
        color_discrete_sequence=["#7000ff", "#01ff80", "#ffbe41", "#05d9e8"]
    )
    
    # D√©sactiver toutes les interactions possibles
    fig_modules.update_layout(
        dragmode=False,
        hovermode=False
    )
    
    # Afficher le graphique de mani√®re compl√®tement statique
    st.plotly_chart(fig_modules, use_container_width=True, config={'displayModeBar': False, 'staticPlot': True})
    
    # S√©lections du jour
    st.markdown("### üìä S√©lections du Combin√©")
    
    # Cr√©ation des s√©lections
    selections = [
        {
            "match": "PSG vs Lyon",
            "league": "Ligue 1",
            "prediction": "PSG gagne",
            "odds": 1.82,
            "confidence": 86,
            "key_factors": ["Momentum favorable: +23%", "Cycle karmique positif", "Delta de cote: 0.21"]
        },
        {
            "match": "Barcelona vs Atletico Madrid",
            "league": "La Liga",
            "prediction": "Plus de 2.5 buts",
            "odds": 1.95,
            "confidence": 79,
            "key_factors": ["Tarot: La Tour (renversement)", "Convergence offensive: 68%", "Historique: 8/10 matchs"]
        },
        {
            "match": "Liverpool vs Chelsea",
            "league": "Premier League",
            "prediction": "Les deux √©quipes marquent",
            "odds": 2.10,
            "confidence": 84,
            "key_factors": ["Planetary transit: Jupiter+Mars", "Anomalie de cote: -0.32", "Attack strength: +17%"]
        }
    ]
    
    # Afficher les s√©lections dans des cartes visuelles
    for selection in selections:
        conf_color = "#01ff80" if selection["confidence"] >= 80 else "#ffbe41"
        
        st.markdown(f"""
        <div style="padding: 15px; border-radius: 10px; background: rgba(8, 15, 40, 0.6); 
                    border: 1px solid rgba(81, 99, 149, 0.2); margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <div>
                    <div style="font-size: 18px; font-weight: bold;">{selection["match"]}</div>
                    <div style="font-size: 14px; color: rgba(255, 255, 255, 0.7);">{selection["league"]}</div>
                </div>
                <div style="text-align: right;">
                    <div style="font-size: 22px; font-weight: bold; font-family: 'JetBrains Mono', monospace;">{selection["odds"]}</div>
                    <div style="font-size: 14px; color: {conf_color};">Confiance: {selection["confidence"]}%</div>
                </div>
            </div>
            <div style="background: rgba(112, 0, 255, 0.1); padding: 10px; border-radius: 8px; 
                        border: 1px solid rgba(112, 0, 255, 0.2); margin-bottom: 10px;">
                <div style="font-size: 16px; font-weight: bold; color: #7000ff; margin-bottom: 5px;">
                    üí° Pr√©diction: {selection["prediction"]}
                </div>
            </div>
            <div style="font-size: 14px; color: rgba(255, 255, 255, 0.8);">
                <b>Facteurs cl√©s:</b>
                <ul style="margin-top: 5px; padding-left: 20px;">
                    <li>{selection["key_factors"][0]}</li>
                    <li>{selection["key_factors"][1]}</li>
                    <li>{selection["key_factors"][2]}</li>
                </ul>
            </div>
        </div>
        """, unsafe_allow_html=True)
    
    # Historique des performances
    st.markdown("### üìà Historique des Combin√©s")
    
    history_data = {
        "Date": [(datetime.now() - timedelta(days=i)).strftime("%d/%m/%Y") for i in range(1, 11)],
        "Selections": [np.random.randint(2, 5) for _ in range(10)],
        "Cote": [round(np.random.uniform(3.5, 12.5), 2) for _ in range(10)],
        "R√©sultat": np.random.choice(["‚úÖ Gagn√©", "‚ùå Perdu"], 10, p=[0.6, 0.4])
    }
    
    df_history = pd.DataFrame(history_data)
    st.dataframe(df_history, use_container_width=True)

with tabs[4]:  # Smart Market Recommendations
    st.markdown("## üí° Recommandations intelligentes de march√©")
    st.markdown("Recommandations intelligentes de paris bas√©es sur l'analyse multidimensionnelle des march√©s et des anomalies de cotes.")
    
    # Filtres de march√©
    col1, col2, col3 = st.columns(3)
    with col1:
        selected_sport = st.selectbox("Sport", ["Football", "Basketball", "Tennis", "Hockey"])
    with col2:
        selected_league = st.selectbox("Comp√©tition", ["Toutes", "Ligue 1", "Premier League", "LaLiga", "Bundesliga", "Serie A"])
    with col3:
        market_type = st.selectbox("Type de March√©", ["R√©sultat final", "Les deux √©quipes marquent", "Over/Under", "Handicap", "Score exact"])
    
    # Tableau de bord des opportunit√©s
    st.markdown("### üíé Opportunit√©s D√©tect√©es")
    
    # Cr√©er un tableau d'anomalies de cotes
    anomalies = [
        {
            "match": "PSG vs Lyon",
            "market": "Lyon ou Nul",
            "odds": 2.45,
            "fair_odds": 2.10,
            "value": "+16.7%",
            "confidence": 82,
            "modules": "ShadowOdds, LineTrap"
        },
        {
            "match": "Arsenal vs Liverpool",
            "market": "Plus de 2.5 buts",
            "odds": 1.95,
            "fair_odds": 1.76,
            "value": "+10.8%",
            "confidence": 89,
            "modules": "NumeriCode, AstroImpact"
        },
        {
            "match": "Real Madrid vs Barcelona",
            "market": "Les deux √©quipes marquent",
            "odds": 1.75,
            "fair_odds": 1.58,
            "value": "+10.8%",
            "confidence": 91,
            "modules": "ArcanX, KarmicFlow+"
        },
        {
            "match": "Bayern Munich vs Dortmund",
            "market": "Bayern gagne et Plus de 3.5 buts",
            "odds": 3.25,
            "fair_odds": 2.85,
            "value": "+14.0%",
            "confidence": 76,
            "modules": "EchoPath, MetaSystems"
        },
        {
            "match": "Milan vs Inter",
            "market": "Milan gagne",
            "odds": 3.10,
            "fair_odds": 2.65,
            "value": "+17.0%",
            "confidence": 73,
            "modules": "TarotEcho, ShadowOdds+"
        }
    ]
    
    # Cr√©er un tableau
    anomalies_df = pd.DataFrame(anomalies)
    
    # Appliquer un style conditionnel
    def highlight_value(val):
        if '+' in str(val):
            return 'color: #01ff80; font-weight: bold'
        return ''
    
    # Afficher le tableau avec style - using style.map instead of style.applymap (which is deprecated)
    st.dataframe(anomalies_df.style.map(highlight_value, subset=['value']), use_container_width=True)
    
    # Graphique de distribution des valeurs
    st.markdown("### üìä Distribution des Valeurs sur le March√©")
    
    # Utiliser une image pr√©d√©finie pour √©viter toute interactivit√©
    # Simuler des donn√©es pour l'histogramme
    market_values = np.random.normal(0, 5, 1000)
    thresholds = np.percentile(market_values, [5, 95])
    
    # Cr√©er un histogramme simple avec Plotly mais le convertir en image
    fig_hist = px.histogram(
        market_values, 
        nbins=40,
        title="Distribution de la Valeur (Value) sur le march√©",
        labels={"value": "Valeur (%)", "count": "Nombre de paris"},
        color_discrete_sequence=["#7000ff"]
    )
    
    # Ajouter les lignes de seuil
    fig_hist.add_vline(x=thresholds[0], line_dash="dash", line_color="#ff3364")
    fig_hist.add_vline(x=thresholds[1], line_dash="dash", line_color="#01ff80")
    
    # Ajouter l'annotation
    fig_hist.add_annotation(
        x=thresholds[1] + 1,
        y=50,
        text="Zone de valeur",
        showarrow=True,
        arrowhead=1,
        arrowcolor="#01ff80",
        font=dict(color="#01ff80")
    )
    
    # Mise en page
    fig_hist.update_layout(
        template="plotly_dark",
        margin=dict(l=10, r=10, t=30, b=10),
        height=400,
        dragmode=False,
        xaxis=dict(fixedrange=True),  # D√©sactive le zoom sur l'axe X
        yaxis=dict(fixedrange=True)   # D√©sactive le zoom sur l'axe Y
    )
    
    # Utiliser un rendu statique (en d√©sactivant tous les contr√¥les et interactions)
    st.plotly_chart(
        fig_hist, 
        use_container_width=True, 
        config={
            "staticPlot": True,              # Force un plot statique
            "displayModeBar": False,         # Masque la barre d'outils
            "showTips": False,               # D√©sactive les astuces
            "doubleClick": False,            # D√©sactive le double-clic
            "showAxisDragHandles": False,    # D√©sactive les poign√©es d'axe
            "showAxisRangeEntryBoxes": False, # D√©sactive les bo√Ætes de plage d'axe
            "displaylogo": False             # D√©sactive le logo Plotly
        }
    )
    
    # Analyse √©sot√©rique des influences
    st.markdown("### üîÆ Influences √âsot√©riques Actives")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("""
        <div style="padding: 15px; border-radius: 10px; background: rgba(112, 0, 255, 0.1); 
                    border: 1px solid rgba(112, 0, 255, 0.2); margin-bottom: 15px;">
            <div style="font-size: 18px; font-weight: bold; color: #7000ff; margin-bottom: 10px;">
                ‚ôÉ Jupiter en Transit (Impact: √âlev√©)
            </div>
            <div style="font-size: 14px; color: rgba(255, 255, 255, 0.8);">
                Jupiter en transit dans la maison V favorise les √©quipes dominantes.
                <br><br>
                <b>√âquipes amplifi√©es:</b> PSG, Real Madrid, Man City, Bayern
                <br>
                <b>March√©s favoris√©s:</b> Victoire √† domicile + Over 2.5
            </div>
        </div>
        """, unsafe_allow_html=True)
        
    with col2:
        st.markdown("""
        <div style="padding: 15px; border-radius: 10px; background: rgba(1, 255, 128, 0.1); 
                    border: 1px solid rgba(1, 255, 128, 0.2); margin-bottom: 15px;">
            <div style="font-size: 18px; font-weight: bold; color: #01ff80; margin-bottom: 10px;">
                ·õò Rune Mannaz Active (Impact: Moyen)
            </div>
            <div style="font-size: 14px; color: rgba(255, 255, 255, 0.8);">
                L'influence de Mannaz renforce la coh√©sion d'√©quipe et l'harmonie collective.
                <br><br>
                <b>√âquipes amplifi√©es:</b> Arsenal, Liverpool, Barcelona
                <br>
                <b>March√©s favoris√©s:</b> Les deux √©quipes marquent, Over 1.5 MI-TEMPS
            </div>
        </div>
        """, unsafe_allow_html=True)

with tabs[5]:  # Syst√®me d'Apprentissage
    st.markdown("## üß† Syst√®me d'Apprentissage")
    st.markdown("Visualisation de l'√©volution du syst√®me ArcanShadow et des processus d'apprentissage de ses modules.")
    
    # Vue d'ensemble du syst√®me
    st.markdown("### üîÑ √âtat du Syst√®me ArcanReflex")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(label="Modules Actifs", value="14/16", delta="+1")
    with col2:
        st.metric(label="Apprentissage", value="73%", delta="+5.2%")
    with col3:
        st.metric(label="Adaptation", value="91%", delta="+2.8%")
    with col4:
        st.metric(label="Pr√©cision", value="87%", delta="+3.5%")
    
    # Visualisation des connexions entre modules
    st.markdown("### üåê R√©seau Neural ArcanBrain")
    
    # Cr√©er un r√©seau de modules en apprentissage
    nodes = [
        "ArcanX", "ShadowOdds", "NumeriCode", "TarotEcho", "AstroImpact", 
        "KarmicFlow+", "EchoPath", "MetaSystems", "GridSync", "ArcanSentinel"
    ]
    
    connections = []
    for i in range(len(nodes)):
        for j in range(i+1, len(nodes)):
            if np.random.random() < 0.4:  # 40% de chance d'avoir une connexion
                connections.append((i, j, np.random.uniform(0.1, 1.0)))
    
    # Pr√©parer les donn√©es pour le graphique
    edge_x = []
    edge_y = []
    edge_weights = []
    
    # Cr√©er une disposition circulaire pour les n≈ìuds
    node_x = [np.cos(2*np.pi*i/len(nodes)) for i in range(len(nodes))]
    node_y = [np.sin(2*np.pi*i/len(nodes)) for i in range(len(nodes))]
    
    for src, dst, weight in connections:
        edge_x.extend([node_x[src], node_x[dst], None])
        edge_y.extend([node_y[src], node_y[dst], None])
        edge_weights.append(weight)
    
    # Cr√©er le graphique
    fig = go.Figure()
    
    # Ajouter les liens
    for i in range(0, len(edge_x), 3):
        opacity = min(1, edge_weights[i//3] * 2)
        width = 1 + 3 * edge_weights[i//3]
        fig.add_trace(go.Scatter(
            x=edge_x[i:i+3], y=edge_y[i:i+3],
            line=dict(width=width, color=f'rgba(112, 0, 255, {opacity})'),
            hoverinfo='none',
            mode='lines'
        ))
    
    # Ajouter les n≈ìuds
    node_colors = ['#7000ff', '#01ff80', '#ffbe41', '#05d9e8', '#ff3364', 
                  '#7000ff', '#01ff80', '#ffbe41', '#05d9e8', '#ff3364']
    
    fig.add_trace(go.Scatter(
        x=node_x, y=node_y,
        mode='markers+text',
        text=nodes,
        textposition="top center",
        marker=dict(
            showscale=False,
            color=node_colors,
            size=20,
            line_width=2,
            line=dict(color='white')
        )
    ))
    
    fig.update_layout(
        title="R√©seau de connexions entre modules",
        showlegend=False,
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        plot_bgcolor='rgba(0,0,0,0)',
        margin=dict(b=0, l=0, r=0, t=40),
        template="plotly_dark",
        height=500,
        dragmode=False,
        hovermode=False
    )
    
    # Rendre le graphique compl√®tement statique
    st.plotly_chart(fig, use_container_width=True, config={'displayModeBar': False, 'staticPlot': True})
    
    # Tableau de bord des √©v√©nements d'apprentissage
    st.markdown("### üìù √âv√©nements d'apprentissage r√©cents")
    
    # Cr√©er des donn√©es d'√©v√©nements simul√©es
    events = [
        {
            "timestamp": "17/05/2025 18:12",
            "type": "Pattern Recalibration",
            "module": "TarotEcho",
            "description": "Recalibrage des patterns de r√©currence La Tour + L'√âtoile"
        },
        {
            "timestamp": "17/05/2025 15:47",
            "type": "Transfer Learning",
            "module": "ArcanX",
            "description": "Transfert de connaissance entre contextes Premier League ‚Üí Ligue 1"
        },
        {
            "timestamp": "17/05/2025 14:33",
            "type": "Module Activation",
            "module": "ShadowOdds+",
            "description": "Activation apr√®s seuil de pr√©cision atteint (91.3%)"
        },
        {
            "timestamp": "16/05/2025 22:18",
            "type": "Pattern Recalibration",
            "module": "NumeriCode",
            "description": "Ajustement des s√©quences num√©riques 3-7-11 ‚Üí 3-7-12"
        },
        {
            "timestamp": "16/05/2025 17:52",
            "type": "Architecture Update",
            "module": "GridSync",
            "description": "Optimisation de la couche de convergence +8.2% efficacit√©"
        }
    ]
    
    # Cr√©er un dataframe
    events_df = pd.DataFrame(events)
    st.dataframe(events_df, use_container_width=True)
    
    # Syst√®me de logs d√©taill√©s
    st.markdown("### üìã Logs d'apprentissage d√©taill√©s")
    
    learning_logs = """
2025-05-17 18:12:23 [INFO] [TarotEcho] Pattern Recalibration initiated
2025-05-17 18:12:24 [INFO] [TarotEcho] Analyzing historical pattern accuracy for sequence La Tour + L'√âtoile
2025-05-17 18:12:28 [INFO] [TarotEcho] Previous accuracy for pattern: 76.3%
2025-05-17 18:12:29 [INFO] [TarotEcho] Calculating optimized parameters based on most recent results
2025-05-17 18:12:34 [INFO] [TarotEcho] Pattern realignment completed, new parameters saved
2025-05-17 18:12:36 [INFO] [TarotEcho] Post-optimization accuracy estimation: 81.7%
2025-05-17 15:47:11 [INFO] [ArcanX] Transfer Learning procedure initiated
2025-05-17 15:47:12 [INFO] [ArcanX] Source context: Premier League, Target context: Ligue 1
2025-05-17 15:47:15 [INFO] [ArcanX] Analyzing transferable patterns and contextual similarities
2025-05-17 15:47:22 [INFO] [ArcanX] Context overlap factor calculated: 0.72
2025-05-17 15:47:29 [INFO] [ArcanX] Transferring 14 pattern adjustments to target context
2025-05-17 15:47:34 [INFO] [ArcanX] Recalibrating target context parameters with new knowledge
2025-05-17 15:47:39 [INFO] [ArcanX] Transfer learning complete, performance improvement expected: +4.3%
2025-05-17 14:33:07 [INFO] [ShadowOdds+] Module activation criteria met
2025-05-17 14:33:08 [INFO] [ShadowOdds+] Accuracy threshold reached: 91.3%
2025-05-17 14:33:10 [INFO] [ShadowOdds+] Stability threshold reached: 18 consecutive accurate predictions
2025-05-17 14:33:12 [INFO] [SystemCore] Integrating ShadowOdds+ module with ArcanBrain network
2025-05-17 14:33:17 [INFO] [ArcanBrain] New module connection established with ShadowOdds+"""
    
    st.code(learning_logs, language="plaintext")
    
    # Section de recalibration automatique
    st.subheader("‚öôÔ∏è Syst√®me de recalibration automatique")
    
    # Cr√©er un conteneur avec bordure personnalis√©e 
    with st.container():
        st.write("")  # Espace
        # En-t√™te avec titre et statut
        col1, col2 = st.columns([3, 1])
        with col1:
            st.write("#### Processus de recalibration par ArcanBrain")
        with col2:
            st.success("Actif")
        
        # Description
        st.write("""
            ArcanBrain surveille en permanence les performances du syst√®me et proc√®de automatiquement
            √† des recalibrations intelligentes des modules pr√©dictifs, selon leurs besoins sp√©cifiques.
            Les processus de recalibration sont enti√®rement g√©r√©s par l'intelligence syst√®me.
        """)
        
        # Modes de recalibration dans une bo√Æte info
        st.info("#### Modes de recalibration automatiques")
        
        modes = {
            "Standard": "Recalibration basique sur les derni√®res donn√©es",
            "Deep Learning": "Restructuration compl√®te des couches de patterns",
            "Transfer Learning": "Application des connaissances d'une ligue √† une autre",
            "Pattern Recognition": "Focus sur la d√©tection des motifs r√©currents"
        }
        
        for mode, description in modes.items():
            st.write(f"‚Ä¢ **{mode}:** {description}")
        
        # Informations syst√®me
        st.write("---")
        col1, col2 = st.columns(2)
        with col1:
            st.write("**Dernier diagnostic syst√®me:**")
        with col2:
            st.write("Tous les modules fonctionnent dans les param√®tres optimaux.")
        
        col1, col2 = st.columns(2)
        with col1:
            st.write("**Temps √©coul√© depuis la derni√®re recalibration:**")
        with col2:
            st.write("3h 17min")
    
    st.markdown("### üìä M√©triques ArcanReflex")
    
    # Cr√©er des m√©triques de performance et d'apprentissage
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric(label="Stabilit√© des patterns", value="92.4%", delta="+3.8%")
    with col2:
        st.metric(label="Vitesse d'adaptation", value="23.7 ms", delta="-4.2 ms")
    with col3:
        st.metric(label="Profondeur d'analyse", value="96.3%", delta="+2.1%")
    
    # Graphique d'√©volution de l'apprentissage sur 30 jours
    st.markdown("#### √âvolution des performances sur 30 jours")
    
    # Simuler des donn√©es d'√©volution
    dates = [(datetime.now() - timedelta(days=i)).strftime("%d-%m") for i in range(30, 0, -1)]
    precision_values = [75 + 0.5*i + np.random.normal(0, 2) for i in range(30)]
    precision_values = [min(max(v, 70), 99) for v in precision_values]  # Limiter entre 70% et 99%
    
    # Cr√©er le graphique avec Plotly
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=dates, 
        y=precision_values,
        mode='lines+markers',
        name='Pr√©cision',
        line=dict(color='#01ff80', width=2),
        marker=dict(size=6, color='#01ff80')
    ))
    
    fig.update_layout(
        title="√âvolution de la pr√©cision pr√©dictive",
        xaxis_title="Date",
        yaxis_title="Pr√©cision (%)",
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        font=dict(color='rgba(255, 255, 255, 0.8)'),
        height=350,
        margin=dict(l=40, r=40, t=40, b=40),
        xaxis=dict(showgrid=False),
        yaxis=dict(showgrid=True, gridcolor='rgba(255, 255, 255, 0.1)')
    )
    
    # Rendre le graphique statique
    st.plotly_chart(fig, use_container_width=True, config={'displayModeBar': False, 'staticPlot': True})

# Nouvel onglet pour les Aper√ßus & Matchs Sp√©ciaux
with tabs[7]:
    try:  # Utiliser un bloc try/except global pour √©viter que tout l'onglet ne plante
        st.markdown("## üåü Aper√ßus & Matchs Sp√©ciaux")
        st.markdown("D√©couvrez les matchs √† la une et l'ensemble des rencontres du jour avec les pr√©dictions ArcanShadow.")
        
        # SECTION 1: MATCHS √Ä LA UNE
        st.markdown("### ‚≠ê Matchs √† la une")
        
        # Validation des donn√©es featured_matches
        valid_featured = []
        if isinstance(featured_matches, list):
            for m in featured_matches:
                if isinstance(m, dict):
                    valid_featured.append(m)
        
        if not valid_featured:
            st.info("Aucun match √† la une aujourd'hui")
        else:
            # Afficher les matchs √† la une dans un format simplifi√©
            for i, match in enumerate(valid_featured):
                try:
                    # Extraire toutes les donn√©es avec validation
                    try:
                        home_prob = float(match.get('home_prob', 0.45))
                    except (TypeError, ValueError):
                        home_prob = 0.45
                        
                    try:
                        draw_prob = float(match.get('draw_prob', 0.25))
                    except (TypeError, ValueError):
                        draw_prob = 0.25
                        
                    try:
                        away_prob = float(match.get('away_prob', 0.30))
                    except (TypeError, ValueError):
                        away_prob = 0.30
                    
                    # Classes de probabilit√© pour les couleurs
                    home_class = "high" if home_prob >= 0.6 else ("medium" if home_prob >= 0.4 else "low")
                    draw_class = "high" if draw_prob >= 0.6 else ("medium" if draw_prob >= 0.4 else "low")
                    away_class = "high" if away_prob >= 0.6 else ("medium" if away_prob >= 0.4 else "low")
                    
                    # Autres informations du match
                    country_code = str(match.get('country_code', 'fr')).lower()
                    home_team = match.get('home', match.get('home_team', '?'))
                    away_team = match.get('away', match.get('away_team', '?'))
                    league = match.get('league', '')
                    
                    # Heure du match (avec plusieurs options de fallback)
                    match_time = match.get('time', match.get('kickoff_time', '??:??'))
                    
                    # Utiliser des √©l√©ments Streamlit standard au lieu du HTML complexe
                    st.markdown(f"""
                    <div style="padding: 15px; border-radius: 10px; background: linear-gradient(135deg, rgba(8, 15, 40, 0.8), rgba(17, 23, 64, 0.7)); 
                               border: 1px solid rgba(112, 0, 255, 0.2); margin-bottom: 15px;">
                        <div style="font-size: 13px; color: rgba(255, 255, 255, 0.7); margin-bottom: 5px;">
                            <img src="https://flagcdn.com/16x12/{country_code}.png" width="16" height="12" style="vertical-align: middle; margin-right: 5px;">
                            {league} ‚Ä¢ {match_time}
                        </div>
                        <div style="font-size: 20px; font-weight: bold; color: white; margin: 10px 0;">
                            {home_team} <span style="color: rgba(255, 255, 255, 0.5);">vs</span> {away_team}
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 14px; margin-top: 10px;">
                            <div style="text-align: center; flex: 1;">
                                <div style="color: white;">1</div>
                                <div style="color: #01ff80;">{int(home_prob * 100)}%</div>
                            </div>
                            <div style="text-align: center; flex: 1;">
                                <div style="color: white;">X</div>
                                <div style="color: #ffbe41;">{int(draw_prob * 100)}%</div>
                            </div>
                            <div style="text-align: center; flex: 1;">
                                <div style="color: white;">2</div>
                                <div style="color: #ff3364;">{int(away_prob * 100)}%</div>
                            </div>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                except Exception as e:
                    # Ignorer silencieusement les erreurs individuelles pour ne pas bloquer l'interface
                    pass
        
        # SECTION 2: MATCHS DU JOUR
        st.markdown("### üóìÔ∏è Matchs du jour")
        
        # Validation des donn√©es today_matches
        valid_matches = []
        if isinstance(today_matches, list):
            for m in today_matches:
                if isinstance(m, dict):
                    valid_matches.append(m)
        
        if not valid_matches:
            st.info("Aucun match disponible pour aujourd'hui")
        else:
            # Extraction des ligues pour le filtre
            leagues = set()
            for match in valid_matches:
                if 'league' in match:
                    leagues.add(match['league'])
            
            # Widget de filtre am√©lior√©
            filter_options = ["Toutes les ligues"] + sorted(list(leagues))
            selected_filters = st.multiselect(
                "Filtrer par ligue",
                filter_options,
                default=["Toutes les ligues"]
            )
            
            # Application du filtre
            filtered_matches = valid_matches
            if selected_filters and "Toutes les ligues" not in selected_filters:
                filtered_matches = [m for m in valid_matches if m.get('league', '') in selected_filters]
            
            if not filtered_matches:
                st.info("Aucun match ne correspond aux crit√®res de filtre")
            else:
                # Afficher les matchs en deux colonnes
                col1, col2 = st.columns(2)
                
                for i, match in enumerate(filtered_matches):
                    try:
                        col = col1 if i % 2 == 0 else col2
                        with col:
                            # Extraire et valider les donn√©es
                            try:
                                home_prob = float(match.get('home_prob', 0.33))
                            except (TypeError, ValueError):
                                home_prob = 0.33
                                
                            try:
                                draw_prob = float(match.get('draw_prob', 0.33))
                            except (TypeError, ValueError):
                                draw_prob = 0.33
                                
                            try:
                                away_prob = float(match.get('away_prob', 0.33))
                            except (TypeError, ValueError):
                                away_prob = 0.33
                            
                            # Informations du match
                            home_team = match.get('home', match.get('home_team', '?'))
                            away_team = match.get('away', match.get('away_team', '?'))
                            match_time = match.get('time', match.get('kickoff_time', '??:??'))
                            league_name = match.get('league', '')
                            country_code = str(match.get('country_code', 'fr')).lower()
                            
                            # Classes pour le code couleur
                            home_class = "green" if home_prob >= 0.6 else ("orange" if home_prob >= 0.4 else "red")
                            draw_class = "green" if draw_prob >= 0.6 else ("orange" if draw_prob >= 0.4 else "red")
                            away_class = "green" if away_prob >= 0.6 else ("orange" if away_prob >= 0.4 else "red")
                            
                            # Carte de match simplifi√©e
                            st.markdown(f"""
                            <div style="border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; padding: 10px; margin-bottom: 10px; background: rgba(17, 23, 64, 0.7);">
                                <div style="font-size: 12px; color: rgba(255, 255, 255, 0.7); margin-bottom: 5px;">
                                    <img src="https://flagcdn.com/16x12/{country_code}.png" width="16" height="12" style="vertical-align: middle; margin-right: 5px;">
                                    {league_name} ‚Ä¢ {match.get('full_date_time', f"{match.get('formatted_date', '')} √† {match_time}")}
                                </div>
                                <div style="font-size: 15px; font-weight: bold; color: white; margin-bottom: 8px;">
                                    {home_team} <span style="color: rgba(255, 255, 255, 0.5);">vs</span> {away_team}
                                </div>
                                <div style="display: flex; justify-content: space-between; font-size: 13px;">
                                    <div style="text-align: center; flex: 1;">
                                        <div>1</div>
                                        <div>{int(home_prob * 100)}%</div>
                                    </div>
                                    <div style="text-align: center; flex: 1;">
                                        <div>X</div>
                                        <div>{int(draw_prob * 100)}%</div>
                                    </div>
                                    <div style="text-align: center; flex: 1;">
                                        <div>2</div>
                                        <div>{int(away_prob * 100)}%</div>
                                    </div>
                                </div>
                            </div>
                            """, unsafe_allow_html=True)
                    except Exception as e:
                        # Ignorer silencieusement pour ne pas bloquer l'interface
                        pass
    except Exception as main_error:
        # Gestion globale des erreurs
        st.error("Impossible d'afficher les matchs. Veuillez r√©essayer plus tard.")

# Onglet Donn√©es R√©elles 
with tabs[8]:  # Donn√©es R√©elles
    st.markdown("## üåç Donn√©es R√©elles de Football")
    
    try:
        # Essayer d'importer et d'afficher l'onglet de donn√©es r√©elles
        display_real_data_tab()
    except Exception as e:
        st.error(f"Une erreur s'est produite lors du chargement des donn√©es r√©elles : {str(e)}")
        st.info("Cet onglet vous permet d'analyser les donn√©es r√©elles des principales ligues de football europ√©ennes.")
        
        # Afficher une interface simple en cas d'erreur
        st.markdown("""
        ### Fonctionnalit√©s disponibles
        
        Cet onglet int√®gre les donn√©es r√©elles de football et offre:
        - Visualisation des matchs √† venir dans les principales ligues
        - Analyses pr√©dictives bas√©es sur des statistiques r√©elles
        - Recommandations de paris avec √©valuation des probabilit√©s
        - Historique des confrontations entre √©quipes
        - Analyses de forme et tendances des √©quipes
        """)
        
        # Bouton pour r√©essayer
        if st.button("R√©essayer"):
            st.rerun()

# Nouvel onglet Notifications
with tabs[6]:  # Notifications
    st.markdown("## üì¨ Centre de Notifications")
    st.markdown("Toutes les informations importantes du syst√®me ArcanShadow sont centralis√©es ici.")
    
    # Structure pour g√©rer les notifications
    if 'notifications' not in st.session_state:
        st.session_state.notifications = [
            {
                "id": 1,
                "type": "recalibration",
                "title": "Recalibration automatique de ArcanX",
                "message": "ArcanBrain a d√©tect√© une d√©rive de performance de 3.7% sur ArcanX et a proc√©d√© √† une recalibration Deep Learning. Performance am√©lior√©e de +5.2%.",
                "timestamp": "2025-05-17 09:14:32",
                "read": False,
                "priority": "medium"
            },
            {
                "id": 2,
                "type": "pattern",
                "title": "Nouveau pattern d√©tect√© par ArcanReflex",
                "message": "Un pattern cyclique de type Fibonacci a √©t√© identifi√© dans les r√©sultats de la Premier League. Ce motif a √©t√© int√©gr√© au module KarmicFlow+.",
                "timestamp": "2025-05-16 21:03:47",
                "read": False,
                "priority": "high"
            },
            {
                "id": 3,
                "type": "sentinel",
                "title": "Analyse en direct PSG vs Lyon",
                "message": "ArcanSentinel a d√©tect√© une augmentation de l'√©nergie offensive de Lyon √† la 37e minute, sugg√©rant une probabilit√© accrue de but avant la mi-temps.",
                "timestamp": "2025-05-16 15:37:21",
                "read": False,
                "priority": "urgent"
            },
            {
                "id": 4,
                "type": "module",
                "title": "Nouveau module recommand√© par D-forge",
                "message": "D-forge a identifi√© le besoin d'un nouveau module 'ResilienceCore' pour analyser la capacit√© des √©quipes √† rebondir apr√®s un but encaiss√©. Requ√™te envoy√©e √† ArcanConceptor.",
                "timestamp": "2025-05-15 18:42:09",
                "read": True,
                "priority": "medium"
            },
            {
                "id": 5,
                "type": "performance",
                "title": "Synth√®se de performance hebdomadaire",
                "message": "Taux de pr√©cision global: 78.3% (+2.1% vs semaine pr√©c√©dente). Modules les plus performants: TarotEcho (83.9%), ArcanX (81.7%), KarmicFlow+ (80.3%).",
                "timestamp": "2025-05-15 08:00:00", 
                "read": True,
                "priority": "medium"
            }
        ]
    
    # Filtres pour les notifications
    col1, col2 = st.columns([1, 2])
    with col1:
        filter_option = st.selectbox("Filtrer par", ["Toutes", "Non lues", "Recalibration", "Pattern", "Sentinel", "Module", "Performance"], index=0)
    with col2:
        sort_option = st.radio("Trier par", ["Plus r√©cent", "Plus ancien", "Priorit√©"], horizontal=True)
    
    # Appliquer les filtres
    filtered_notifications = st.session_state.notifications.copy()
    if filter_option == "Non lues":
        filtered_notifications = [n for n in filtered_notifications if not n["read"]]
    elif filter_option != "Toutes":
        filter_type = filter_option.lower()
        filtered_notifications = [n for n in filtered_notifications if n["type"] == filter_type]
    
    # Appliquer le tri
    if sort_option == "Plus r√©cent":
        filtered_notifications.sort(key=lambda x: x["timestamp"], reverse=True)
    elif sort_option == "Plus ancien":
        filtered_notifications.sort(key=lambda x: x["timestamp"])
    elif sort_option == "Priorit√©":
        priority_order = {"urgent": 0, "high": 1, "medium": 2, "low": 3}
        filtered_notifications.sort(key=lambda x: (priority_order.get(x["priority"], 4), x["timestamp"]), reverse=True)
    
    # Bouton pour marquer toutes les notifications comme lues
    if st.button("Marquer toutes comme lues"):
        for notif in st.session_state.notifications:
            notif["read"] = True
        st.session_state.notification_count = 0
        st.rerun()
    
    # Affichage des notifications
    st.markdown("### Notifications r√©centes")
    
    if not filtered_notifications:
        st.info("Aucune notification ne correspond aux filtres s√©lectionn√©s.")
    
    for notification in filtered_notifications:
        # Couleur bas√©e sur le type et la priorit√©
        color_map = {
            "recalibration": "#7000ff",  # Violet
            "pattern": "#01ff80",  # Vert
            "sentinel": "#ff3860",  # Rouge
            "module": "#ffbe41",  # Orange
            "performance": "#3273dc"  # Bleu
        }
        
        priority_bg = {
            "urgent": "rgba(255, 56, 96, 0.15)",
            "high": "rgba(255, 190, 65, 0.15)",
            "medium": "rgba(112, 0, 255, 0.15)",
            "low": "rgba(50, 115, 220, 0.15)"
        }
        
        border_color = color_map.get(notification["type"], "#3273dc")
        bg_color = priority_bg.get(notification["priority"], "rgba(50, 115, 220, 0.15)")
        read_marker = "" if notification["read"] else "üìå "
        
        st.markdown(f"""
        <div style="border-left: 4px solid {border_color}; background: {bg_color}; 
                  border-radius: 5px; padding: 15px; margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <div style="font-weight: bold; font-size: 16px; color: white;">
                    {read_marker}{notification["title"]}
                </div>
                <div style="color: rgba(255, 255, 255, 0.6); font-size: 12px;">
                    {notification["timestamp"]}
                </div>
            </div>
            <p style="color: rgba(255, 255, 255, 0.8); margin: 8px 0;">
                {notification["message"]}
            </p>
        </div>
        """, unsafe_allow_html=True)
        
        # Option pour marquer une notification comme lue
        if not notification["read"]:
            if st.button(f"Marquer comme lu #{notification['id']}", key=f"mark_read_{notification['id']}"):
                for notif in st.session_state.notifications:
                    if notif["id"] == notification["id"]:
                        notif["read"] = True
                        break
                
                # Mettre √† jour le compteur de notifications
                st.session_state.notification_count = sum(1 for n in st.session_state.notifications if not n["read"])
                st.rerun()

with tabs[1]:  # Pr√©dictions
    st.markdown("## üîÆ Pr√©dictions d'ArcanShadow")
    st.markdown("Analyse d√©taill√©e des pr√©dictions pour les matchs s√©lectionn√©s, avec explication des modules contributeurs.")
    
    # S√©lection du match √† analyser
    st.markdown("### ‚öΩ S√©lectionner un match")
    
    # Structure pour les matchs en direct
    if 'live_matches' not in st.session_state:
        st.session_state.live_matches = [
            {"id": 1, "home": "PSG", "away": "Lyon", "league": "Ligue 1", "time": "20:45", "status": "En direct", "minute": "37'", "score": "1-0"},
            {"id": 2, "home": "Liverpool", "away": "Arsenal", "league": "Premier League", "time": "17:30", "status": "En direct", "minute": "68'", "score": "2-1"},
            {"id": 3, "home": "Bayern Munich", "away": "Dortmund", "league": "Bundesliga", "time": "18:30", "status": "En direct", "minute": "52'", "score": "0-0"}
        ]
    
    # Structure pour g√©rer les matchs surveill√©s en direct
    if 'sentinel_monitored_live_matches' not in st.session_state:
        st.session_state.sentinel_monitored_live_matches = []
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        # Tableau des matchs en direct disponibles
        st.markdown("#### üî¥ Matchs actuellement en direct")
        
        for match in st.session_state.live_matches:
            is_monitored = any(m['id'] == match['id'] for m in st.session_state.sentinel_monitored_live_matches)
            status_color = "#01ff80" if is_monitored else "rgba(255, 255, 255, 0.8)"
            status_text = "üü¢ Surveill√© en direct" if is_monitored else "‚ö™ Disponible"
            
            st.markdown(f"""
            <div style="display: flex; justify-content: space-between; align-items: center; 
                      padding: 12px; border-radius: 5px; margin-bottom: 15px; 
                      background: rgba(255, 51, 100, 0.1); border: 1px solid rgba(255, 51, 100, 0.2);">
                <div>
                    <div style="font-weight: bold; font-size: 16px; color: white;">
                        {match['home']} {match['score']} {match['away']}
                    </div>
                    <div style="font-size: 13px; color: #ff3364; font-weight: bold; margin-top: 4px;">
                        {match['minute']} ‚Ä¢ EN DIRECT
                    </div>
                    <div style="font-size: 12px; color: rgba(255, 255, 255, 0.6); margin-top: 2px;">
                        {match['league']}
                    </div>
                </div>
                <div style="font-size: 13px; color: {status_color};">
                    {status_text}
                </div>
            </div>
            """, unsafe_allow_html=True)
            
            # Pour chaque match, ajouter des boutons d'action
            col_a, col_b = st.columns([3, 2])
            with col_a:
                if not is_monitored:
                    if st.button(f"Activer surveillance en direct", key=f"activate_live_notif_{match['id']}"):
                        # Configuration de surveillance
                        surveillance_config = {
                            "id": match['id'],
                            "home": match['home'],
                            "away": match['away'],
                            "league": match['league'],
                            "minute": match['minute'],
                            "score": match['score'],
                            "monitoring_level": "Maximum",  # Plus haut niveau pour les matchs en direct
                            "modules": ["ShadowMomentum", "LineTrap", "KarmicFlow", "MirrorPhase", "BetPulse"],
                            "activated_at": "2025-05-17 " + datetime.now().strftime("%H:%M:%S"),
                            "alert_threshold": 5  # Seuil plus bas pour √™tre plus r√©actif aux matchs en direct
                        }
                        st.session_state.sentinel_monitored_live_matches.append(surveillance_config)
                        
                        # Ajouter une notification d'activation
                        if 'notifications' in st.session_state:
                            new_notif = {
                                "id": len(st.session_state.notifications) + 1,
                                "type": "sentinel",
                                "title": f"üî¥ ArcanSentinel activ√© en DIRECT: {match['home']} vs {match['away']}",
                                "message": f"Surveillance instantan√©e lanc√©e sur le match en direct {match['home']} vs {match['away']} ({match['minute']}). Les analyses seront envoy√©es en temps r√©el.",
                                "timestamp": "2025-05-17 " + datetime.now().strftime("%H:%M:%S"),
                                "read": False,
                                "priority": "urgent"
                            }
                            st.session_state.notifications.append(new_notif)
                            # Mise √† jour du compteur
                            st.session_state.notification_count = sum(1 for n in st.session_state.notifications if not n["read"])
                        
                        st.rerun()
                else:
                    # Utiliser un identifiant unique bas√© sur les informations du match
                    match_id = match.get('id', '')
                    match_key = f"{match.get('home', '')}_{match.get('away', '')}_{match_id}"
                    if st.button(f"D√©sactiver", key=f"deactivate_live_{match_key}"):
                        # Utiliser une comparaison d'objets complets pour la suppression
                        st.session_state.sentinel_monitored_live_matches.remove(match)
                        st.rerun()
    
    with col2:
        st.markdown("#### Configuration pour l'analyse en direct")
        
        st.markdown("""
        <div style="border: 1px solid rgba(255, 51, 100, 0.3); border-radius: 10px; padding: 15px; background: rgba(255, 51, 100, 0.05);">
            <h4 style="color: #ff3364; margin-top: 0;">Surveillance en Direct</h4>
            <p style="color: rgba(255, 255, 255, 0.8); font-size: 14px;">
                ArcanSentinel analyse en temps r√©el:
            </p>
            <ul style="color: rgba(255, 255, 255, 0.8); font-size: 14px;">
                <li>Les changements instantan√©s de dynamique de jeu</li>
                <li>Les r√©actions imm√©diates des cotes en direct</li>
                <li>Les patterns d'√©nergie pendant le match</li>
                <li>Les moments critiques avec forte probabilit√© de but</li>
                <li>Les opportunit√©s de paris optimales en live</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
        
        # Affichage des matchs surveill√©s en direct
        if st.session_state.sentinel_monitored_live_matches:
            st.markdown("#### Matchs en direct sous surveillance")
            for match in st.session_state.sentinel_monitored_live_matches:
                # Simuler une progression du match
                current_minute = match.get('minute', "??'")
                if "'" in current_minute:
                    minute_num = int(current_minute.replace("'", ""))
                    minute_num += 3  # Avancer de quelques minutes
                    current_minute = f"{minute_num}'"
                
                st.markdown(f"""
                <div style="background: rgba(255, 51, 100, 0.15); border: 1px solid rgba(255, 51, 100, 0.3); 
                          border-radius: 5px; padding: 15px; margin-top: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="font-weight: bold; color: white;">
                            {match['home']} {match['score']} {match['away']}
                        </div>
                        <div style="color: #ff3364; font-weight: bold; font-size: 14px;">
                            {current_minute}
                        </div>
                    </div>
                    <div style="margin-top: 10px; font-size: 13px; color: rgba(255, 255, 255, 0.7);">
                        <span style="color: #01ff80;">‚óè</span> Analyse en direct active
                    </div>
                    <div style="font-size: 12px; color: rgba(255, 255, 255, 0.5); margin-top: 5px;">
                        5 modules actifs ‚Ä¢ Seuil d'alerte: {match.get('alert_threshold', 5)}/10
                    </div>
                </div>
                """, unsafe_allow_html=True)
            
            # Information sur le traitement automatique
            st.markdown("""
            <div style="font-size: 13px; color: rgba(255, 255, 255, 0.7); border-left: 2px solid #ff3364; 
                      padding-left: 10px; margin-top: 15px;">
                Les insights d√©tect√©s en direct sont automatiquement envoy√©s √† l'onglet Notifications.
                <br><br>
                Les patterns d√©tect√©s par ArcanSentinel sont transmis √† D-forge pour analyse 
                et d√©veloppement potentiel de nouveaux modules.
            </div>
            """, unsafe_allow_html=True)
        else:
            st.info("Aucun match en direct sous surveillance. Activez ArcanSentinel sur un match en cours pour recevoir des insights en temps r√©el.")
    
    # Affichage des indicateurs en temps r√©el si au moins un match est surveill√©
    if st.session_state.sentinel_monitored_live_matches:
        st.markdown("### üîÑ Indicateurs ArcanSentinel en temps r√©el")
        
        # Prendre le premier match surveill√© pour afficher des donn√©es
        active_match = st.session_state.sentinel_monitored_live_matches[0]
        
        st.markdown(f"""
        <div style="padding: 12px; border-radius: 8px; margin-bottom: 15px; 
                    background: rgba(255, 51, 100, 0.1); border: 1px solid rgba(255, 51, 100, 0.2);">
            <div style="font-weight: bold; font-size: 18px; color: white; margin-bottom: 8px;">
                {active_match['home']} {active_match['score']} {active_match['away']} ‚Ä¢ {active_match['minute']}
            </div>
            <div style="font-size: 13px; color: rgba(255, 255, 255, 0.7);">
                <span style="color: #ff3364; font-weight: bold;">ANALYSE EN DIRECT</span> ‚Ä¢ {active_match['league']}
            </div>
        </div>
        """, unsafe_allow_html=True)
        
        # Surveillance simul√©e
        sentinel_metrics = [
            {"name": "Momentum", "value": 72, "delta": "+3", "color": "#01ff80"},
            {"name": "Variance de cote", "value": 0.18, "delta": "-0.05", "color": "#ffbe41"}, 
            {"name": "Pression collective", "value": 64, "delta": "+8", "color": "#01ff80"},
            {"name": "Cycle karmique", "value": 88, "delta": "+2", "color": "#01ff80"},
            {"name": "Anomalie structurelle", "value": 22, "delta": "-4", "color": "#ff3364"}
        ]
        
        cols = st.columns(len(sentinel_metrics))
        for i, metric in enumerate(sentinel_metrics):
            with cols[i]:
                st.markdown(f"""
                <div style="text-align: center; padding: 10px;">
                    <div style="font-size: 14px; color: rgba(255, 255, 255, 0.7);">{metric['name']}</div>
                    <div style="font-size: 24px; font-weight: bold; color: {metric['color']};">{metric['value']}</div>
                    <div style="font-size: 12px; color: {metric['color']};">{metric['delta']}</div>
                </div>
                """, unsafe_allow_html=True)